---
title: "Maps"
author: "Sofia"
format: html
---

```{r}
library(readr) 
library(tmap)
library(dplyr)
library(sf)
library(stars)
library(spatstat)
library(terra)
library(ggplot2) 
library(tidyr)
worldelevation = read_stars("data/worldelevation.tif")
worldvector = read_sf("data/worldvector.gpkg")
worldcities = read_sf("data/worldcities.gpkg")
```

# Zones Map

```{r}
zones_sf <- st_read("data/zones_shapefile.shp")
st_geometry_type(zones_sf)

tm_shape(zones_sf) + 
  tm_polygons(
    col = "lightblue",        #Color of the polygons
    border.col = "darkblue",   #Color of the borders
    alpha = 0.3               #Set transparency for the fill (0 = fully transparent, 1 = fully opaque)
  ) +
  tm_basemap(server = "Esri.WorldImagery")

```


# Zones Map + Whale Sightings (2014-2024)

```{r}

   tmap_mode("view")  
    
    tm_shape(zones_sf) +  # The shapefile data (zones_sf)
      tm_polygons(
        col = "lightblue",  # Color for polygons
        border.col = "darkblue",  # Color for borders
        alpha = 0.3
      ) +
      tm_borders() +  # Add borders for the polygons
      tm_shape(whale_sf) +
      tm_dots(col = "pink",
              size = 0.5, 
              alpha = 0.8,   # Adjust transparency for visibility
              shape = 21,    # Use a circle with fill
              border.col = "black",  # Ensure there's an outline
              border.lwd = 0.5) +
      tm_basemap(server = "Esri.WorldImagery")  # Add basemap without max.native.zoom
```

##Kernel Density

```{r}
#Kernel Density
#Create a ppp (point pattern) object
whales_ppp <- ppp(x = st_coordinates(humpback_whales_sf)[,1],
                  y = st_coordinates(humpback_whales_sf)[,2],
                  window = owin(c(min(st_coordinates(humpback_whales_sf)[,1]), 
                                  max(st_coordinates(humpback_whales_sf)[,1])), 
                          
                                c(min(st_coordinates(humpback_whales_sf)[,2]), 
                                  max(st_coordinates(humpback_whales_sf)[,2]))))
#Kernel density estimation
kde <- density.ppp(whales_ppp)

#Plot the density
plot(kde)

```

#Humpback Whale

```{r}

#Convert your data into an sf object
humpback_sf <- whale_expanded %>%
  filter(species == "Humpback Whale") %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

#Ensure the data is projected (KDE works best in projected CRS)
humpback_sf <- st_transform(humpback_sf, crs = 32610)  # Replace 32610 with your UTM zone

#Get unique years
years <- unique(humpback_sf$year)

#Loop over years and compute KDE
kde_list <- list()

for (yr in years) {
  # Filter data for the year
  yearly_sf <- humpback_sf[humpback_sf$year == yr, ]
  
#Convert to spatstat format (ppp object)
  yearly_ppp <- as.ppp(st_coordinates(yearly_sf), W = owin(xrange = c(min(st_coordinates(yearly_sf)[,1]), 
                                                                      max(st_coordinates(yearly_sf)[,1])), 
                                                           yrange = c(min(st_coordinates(yearly_sf)[,2]), 
                                                                      max(st_coordinates(yearly_sf)[,2]))))

#Kernel density estimation
  kde_result <- density(yearly_ppp, sigma = 50000)  # Adjust bandwidth (sigma) as needed
  
#Convert KDE to raster
kde_raster <- rast(kde_result)
kde_list[[as.character(yr)]] <- kde_raster  # Store each year's KDE
}

#Plot KDE for each year
par(mfrow = c(4, 4))  # Arrange plots (adjust based on the number of years)
for (yr in names(kde_list)) {
  plot(kde_list[[yr]], main = paste("KDE for", yr))
}

```

#Blue Whale

```{r}

#Convert your data into an sf object
blue_sf <- whale_expanded %>%
  filter(species == "Blue Whale") %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

#Ensure the data is projected (KDE works best in projected CRS)
blue_sf <- st_transform(blue_sf, crs = 32610)  # Replace 32610 with your UTM zone

#Get unique years
years <- unique(blue_sf$year)

#Loop over years and compute KDE
kde_list <- list()

for (yr in years) {
  # Filter data for the year
  yearly_sf <- blue_sf[blue_sf$year == yr, ]
  
#Convert to spatstat format (ppp object)
  yearly_ppp <- as.ppp(st_coordinates(yearly_sf), W = owin(xrange = c(min(st_coordinates(yearly_sf)[,1]), 
                                                                      max(st_coordinates(yearly_sf)[,1])), 
                                                           yrange = c(min(st_coordinates(yearly_sf)[,2]), 
                                                                      max(st_coordinates(yearly_sf)[,2]))))

#Kernel density estimation
  kde_result <- density(yearly_ppp, sigma = 50000)  # Adjust bandwidth (sigma) as needed
  
#Convert KDE to raster
kde_raster <- rast(kde_result)
kde_list[[as.character(yr)]] <- kde_raster  # Store each year's KDE
}

#Plot KDE for each year
par(mfrow = c(4, 4))  # Arrange plots (adjust based on the number of years)
for (yr in names(kde_list)) {
  plot(kde_list[[yr]], main = paste("KDE for", yr))
}



```

#Fin whale

```{r}

#Convert your data into an sf object
fin_sf <- whale_expanded %>%
  filter(species == "Fin Whale") %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

#Ensure the data is projected (KDE works best in projected CRS)
fin_sf <- st_transform(fin_sf, crs = 32610)  # Replace 32610 with your UTM zone

#Get unique years
years <- unique(fin_sf$year)

#Loop over years and compute KDE
kde_list <- list()

for (yr in years) {
  # Filter data for the year
  yearly_sf <- fin_sf[fin_sf$year == yr, ]
  
#Convert to spatstat format (ppp object)
  yearly_ppp <- as.ppp(st_coordinates(yearly_sf), W = owin(xrange = c(min(st_coordinates(yearly_sf)[,1]), 
                                                                      max(st_coordinates(yearly_sf)[,1])), 
                                                           yrange = c(min(st_coordinates(yearly_sf)[,2]), 
                                                                      max(st_coordinates(yearly_sf)[,2]))))

#Kernel density estimation
  kde_result <- density(yearly_ppp, sigma = 50000)  # Adjust bandwidth (sigma) as needed
  
#Convert KDE to raster
kde_raster <- rast(kde_result)
kde_list[[as.character(yr)]] <- kde_raster  # Store each year's KDE
}

#Plot KDE for each year
par(mfrow = c(3, 4))  # Arrange plots (adjust based on the number of years)
for (yr in names(kde_list)) {
  plot(kde_list[[yr]], main = paste("KDE for", yr))
}
```

# Home Ranges with adehanitatHR

```{r}
library(adehabitatHR)

#Load data 
whale_raw <- read_csv("data/whale_cleaned.csv")

# Expand rows based on number_sighted
whale_expanded <- whale_raw %>%
  uncount(weights = number_sighted)  # Duplicates rows based on the value in number_sighted

#Filtering data for each species (if needed)
humpback_whales <- whale_expanded %>% filter(species == "Humpback Whale")
blue_whales <- whale_expanded %>% filter(species == "Blue Whale")
fin_whales <- whale_expanded %>% filter(species == "Fin Whale")

#Create a projection, Create SPDF and Check CRS
#CRS projection, variable prj
prj <- "+init=epsg:4326"


#Creating a SpatialPointsDataFrame

whale_exp <- SpatialPointsDataFrame(coords = coordinates(cbind(whale_expanded$longitude,
                    whale_expanded$latitude)),  
                    data = whale_expanded,  
                    proj4string = CRS(prj))

humpback_w <- SpatialPointsDataFrame(coords = coordinates(cbind(humpback_whales$longitude,
                    humpback_whales$latitude)),  
                    data = humpback_whales,  
                    proj4string = CRS(prj))
                                                          
blue_w <- SpatialPointsDataFrame(coords = coordinates(cbind(blue_whales$longitude,
                    blue_whales$latitude)),  
                    data = blue_whales,  
                    proj4string = CRS(prj))

fin_w <- SpatialPointsDataFrame(coords = coordinates(cbind(fin_whales$longitude,
                    fin_whales$latitude)),  
                    data = fin_whales,  
                    proj4string = CRS(prj))


#quick visualization 
plot(whale_exp, pch= 19, cex = 0.5) 
plot(humpback_w, pch= 19, cex = 0.5)
plot(blue_w, pch= 19, cex = 0.5)
plot(fin_w, pch= 19, cex = 0.5)
```


```{r}
#kernel density 
kernel_whales <- kernelUD(xy = whale_exp,
                           h = "href")
kernel_humpack <- kernelUD(xy = humpback_w,
                           h = "href")
kernel_blue <- kernelUD(xy = blue_w,
                           h = "href")
kernel_fin <- kernelUD(xy = fin_w,
                           h = "href")

#quick visualization 
image(kernel_whales)
image(kernel_humpack)
image(kernel_blue)
image(kernel_fin)
```

# Humpback Whale
```{r}
#extracting 75% and 90%,see in literature which % could be best 
hr_90_humpback <- getverticeshr(x = kernel_humpack, percent = 90) 
hr_75_humpback <- getverticeshr(x = kernel_humpack, percent = 75)

#checking classes 
#class(hr_90_humpback)
#class(hr_75_humpback)

plot(hr_90_humpback, col = "lightblue", main = "Kernel Density Home Range 90% of Humpback Whale 2014-2024")
plot(hr_75_humpback, col = "lightblue", main = "Kernel Density Home Range 75% of Humpback Whale 2014-2024")


```

# Blue Whale
```{r}
#extracting 75% and 90%,see in literature which % could be best 
hr_90_blue <- getverticeshr(x = kernel_blue, percent = 90) 
hr_75_blue <- getverticeshr(x = kernel_blue, percent = 75)

#checking classes 
#class(hr_90_blue)
#class(hr_75_blue)

plot(hr_90_blue, col = "blue", main = "Kernel Density Home Range 90% of Blue Whale 2014-2024")
plot(hr_75_blue, col = "blue", main = "Kernel Density Home Range 75% of Blue  Whale 2014-2024")

```

# Fin Whale 
```{r}
#extracting 75% and 90%,see in literature which % could be best 
hr_90_fin <- getverticeshr(x = kernel_fin, percent = 90) 
hr_75_fin <- getverticeshr(x = kernel_fin, percent = 75)

#checking classes 
#class(hr_90_fin)
#class(hr_75_fin)

plot(hr_90_fin, col = "gray12", main = "Kernel Density Home Range 90% of Fin Whale 2014-2024")
plot(hr_75_fin, col = "gray12", main = "Kernel Density Home Range 75% of Fin Whale 2014-2024")
```

```{r}
#Converting into SF, to it can be plotted in Tmap

hr_90_humpback_sf <- st_as_sf(hr_90_humpback)
hr_75_humpback_sf <- st_as_sf(hr_75_humpback)
hr_90_blue_sf <- st_as_sf(hr_90_blue)
hr_75_blue_sf <- st_as_sf(hr_75_blue)
hr_90_fin_sf <- st_as_sf(hr_90_fin)
hr_75_fin_sf <- st_as_sf(hr_75_fin)

```

# Home Range TMaps 

```{r}

#Humpback Whale
   tmap_mode("view")  
    
    tm_shape(hr_90_humpback_sf) +  # The shapefile data (zones_sf)
      tm_polygons(
        col = "lightblue",  # Color for polygons
        border.col = "darkblue",  # Color for borders
        alpha = 0.5
      ) +
      tm_borders() +  # Add borders for the polygons
      tm_shape(hr_75_humpback_sf) +
      tm_polygons(
              col = "hotpink",
              border.col = "darkblue", 
              alpha = 0.5) +
      tm_basemap(server = "Esri.WorldImagery") +
      tm_add_legend(
        type = "fill",
        labels = c("90% Kernel density", "75% Kernel density"),
        col = c("lightblue", "hotpink"))

```

```{r}
#Blue Whale 

tmap_mode("view")  
    
    tm_shape(hr_90_blue_sf) +  # The shapefile data (zones_sf)
      tm_polygons(
        col = "lightblue",  # Color for polygons
        border.col = "darkblue",  # Color for borders
        alpha = 0.5
      ) +
      tm_borders() +  # Add borders for the polygons
      tm_shape(hr_75_blue_sf) +
      tm_polygons(
              col = "hotpink",
              border.col = "darkblue", 
              alpha = 0.5) +
      tm_basemap(server = "Esri.WorldImagery") +
      tm_add_legend(
        type = "fill",
        labels = c("90% Kernel density", "75% Kernel density"),
        col = c("lightblue", "hotpink"))


```

```{r}
#Fin Whale 
tmap_mode("view")  
    
    tm_shape(hr_90_fin_sf) +  # The shapefile data (zones_sf)
      tm_polygons(
        col = "lightblue",  # Color for polygons
        border.col = "darkblue",  # Color for borders
        alpha = 0.5
      ) +
      tm_borders() +  # Add borders for the polygons
      tm_shape(hr_75_fin_sf) +
      tm_polygons(
              col = "hotpink",
              border.col = "darkblue", 
              alpha = 0.5) +
      tm_basemap(server = "Esri.WorldImagery") +
      tm_add_legend(
        type = "fill",
        labels = c("90% Kernel density", "75% Kernel density"),
        col = c("lightblue", "hotpink"))
```


#Home range plots + masking with shapefile (excluding continient)
```{r}



